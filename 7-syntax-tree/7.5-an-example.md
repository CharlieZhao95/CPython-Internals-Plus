# 7.5 一个示例：添加一个约等于比较运算法

如果要将本章节所有内容串联起来，你可以在 Python 语言中添加一个新的语法特性并重新编译 CPython 来掌握本章节内容。

一个**比较表达式**会比较两个及以上的值，比如：

<figure><img src="../.gitbook/assets/图7.5.1 比较表达式.png" alt=""><figcaption></figcaption></figure>

在比较表达式中用到的运算符被称为**比较运算符**。以下可能是你知道的一些比较运算符：

* <：小于；
* \>：大于；
* \==：等于；
* !=：不等于。

{% hint style="info" %}
**See Also**

[PEP 207](https://peps.python.org/pep-0207/) 为 Python 2.1 提出了在数据模型中的丰富比较运算符。此 PEP 包含了自定义 Python 类型实现比较方法的上下文、历史以及解释。
{% endhint %}

我们将添加另外一个比较运算符：**约等于**，由 `~=` 表示并有如下行为：

* 如果你比较一个浮点数和一个整数，其会将浮点数转换为整数并比较结果；
* 如果你比较两个整数，其会使用普通的相等运算符。

一旦实现此特性，新的运算符会在交互式解释器中返回如下结果：

<figure><img src="../.gitbook/assets/图7.5.2 约等于表达式.png" alt=""><figcaption></figcaption></figure>

为了添加新的运算符，首先你需要更新 CPython 语法。

在 `Grammar/Grammar` 文件中，比较运算符被定义为一个符号：`comp_op` ：

<figure><img src="../.gitbook/assets/图7.5.3 comp_op定义.png" alt=""><figcaption></figcaption></figure>

修改此行以在 '!='| 和 |'in' 之间添加 `~=` 运算符。

<figure><img src="../.gitbook/assets/图7.5.4 修改语法.png" alt=""><figcaption></figcaption></figure>

为了更新 C 语言中的语法和单词符号，你需要重新生成头文件：

在 MacOS/Linux上执行 make 命令：

<figure><img src="../.gitbook/assets/图7.5.5 重新生成语法.png" alt=""><figcaption></figcaption></figure>

在 Windows 上运行 `PCBuild` 目录中的 build.bat 文件：

<figure><img src="../.gitbook/assets/图7.5.6 在Windows上重新生成语法.png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
**Note**

译者注：原书有误，修改 Grammar 文件修改后重新编译 CPython 会报错（`KeyError: '~='`），因为 pgen 模块还无法识别 `~=` 符号，需要在 Tokens 文件中添加 `ALMOSTEQUAL '~='`。
{% endhint %}

词法分析器会通过这些步骤自动更新。比如：打开 `Parser/token.c` 源文件，你可以看到 [PyToken\_TwoChars()](https://github.com/python/cpython/blob/v3.9.0b1/Parser/token.c#L109) 函数已经被修改：

<figure><img src="../.gitbook/assets/图7.5.7 更新PyToken_TwoChars().png" alt=""><figcaption></figcaption></figure>

如果你在这个阶段重新编译 CPython 并且打开一个交互式解释器，你可以看到词法分析器已经可以成功识别到这一个单词符号，但是此时抽象语法树还不知道如何处理它：

<figure><img src="../.gitbook/assets/图7.5.8 系统错误.png" alt=""><figcaption></figcaption></figure>

这个异常是由 `Python/ast.c`  文件中的 [ast\_for\_comp\_op()](https://github.com/python/cpython/blob/v3.9.0b1/Python/ast.c#L1199) 函数引起，原因是交互式解释器还无法把 `ALMOSTEQUAL` 识别为一个比较运算符中的一个有效运算符。

`Compare` 是一个定义在 `Parser/Python.asdl` 文件中的一个表达式类型，其具有的属性：左表达式、操作符（`ops`）列表以及一个要比较的表达式列表（`comparators`）：

<figure><img src="../.gitbook/assets/图7.5.9 asdl中Compare定义.png" alt=""><figcaption></figcaption></figure>

在 `Compare` 定义中是对 `cmpop` 枚举的引用：

<figure><img src="../.gitbook/assets/图7.5.10 cmpop定义.png" alt=""><figcaption></figcaption></figure>

这是一个可以充当比较运算符的抽象语法树叶子节点的列表集合。我们定义的约等于运算符没在里面所以需要补充完整。更新这个选项集合来包含一个新类型：ALE（**Al**most **E**qual）：

<figure><img src="../.gitbook/assets/图7.5.11 修改cmpop定义.png" alt=""><figcaption></figcaption></figure>

接下来，我们重新生成抽象语法树来更新抽象语法树的 C 头文件：

<figure><img src="../.gitbook/assets/图7.5.12 重新生成抽象语法树结构.png" alt=""><figcaption></figcaption></figure>

这个操作会更新比较运算符（`_cmpop`），在 `Include/Python-ast.h` 文件中的枚举会包含 `ALE` 选项：

<figure><img src="../.gitbook/assets/图7.5.13 Python-ast.h中重新生成的_cmpop.png" alt=""><figcaption></figcaption></figure>

抽象语法树此时还没有能力将 `ALMOSTEQUAL` 单词符号和 `ALE` 比较运算符关联上。所以你还要为抽象语法树更新 C 语言代码。

找到 `Python/ast.c` 文件中的 [ast\_for\_comp\_op()](https://github.com/python/cpython/blob/v3.9.0b1/Python/ast.c#L1199) 函数并找到运算符单词符号的 switch 语句。这个函数会返回 `_cmop` 枚举值中的一个。

<figure><img src="../.gitbook/assets/图7.5.14 ast_for_comp_op定义1.png" alt=""><figcaption></figcaption></figure>

添加两行代码用于捕捉 `ALMOSTEQUAL` 单词符号并返回 `AlE` 比较运算符：

<figure><img src="../.gitbook/assets/图7.5.15 ast_for_comp_op定义2.png" alt=""><figcaption></figcaption></figure>

现在重新编译 CPython 并重新打开一个交互式解释器来测试命令行：

<figure><img src="../.gitbook/assets/图7.5.16 执行约等于.png" alt=""><figcaption></figcaption></figure>

在这个阶段，词法分析器和抽象语法树可以解析代码，但是编译器还是不知道如何处理这个运算符。为了测试抽象语法树的表示，我们可以使用 `ast.parse()` 函数来探索表达式的第一个运算符：

<figure><img src="../.gitbook/assets/图7.5.17 用ast模块解析约等于.png" alt=""><figcaption></figcaption></figure>

这是我们 `AlE` 比较运算符类型的一个实例，因此抽象语法树才能正确的解析代码。

在下一个章节，你会继续学习 CPython 编译器是如何工作的，并且重新审视约等于运算符来构建其行为。
